---
title: "정보처리기사 1과목 3장"
date: 2021-06-06
category: etc
tags:
  - 정보처리기사
published: false
---
정보처리기사 1강 3장
## <21> 소프트웨어 아키텍처 

1. 소프트웨어 아키텍처의 설계
  : 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
  : 기본적으로 좋은 품질을 유지하면서, 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다. 
  : 애플리케이션의 분할 방법과 분할된 모듈에 할당된 기능, 모듈 간의 인터페이스를 결정한다. 

  상위 설계
    : 시스템의 전체적인 구조
  하위 설계
    : 시스템의 내부 구조 및 행위

  1. 모듈화(Modularity)
    - 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것 
    - 모듈 크기를 너무 작게 나누면 개수가 많아져 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다. 

  2. 추상화(Abstraction)
    - 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다. 
    - 불필요한 부분을 생략하고 필요한 부분을 강조하여 모델화 하는 것 
    1. 과정 추상화 : 전반적인 흐름만 파악할 수 있게 설계하는 방법
    2. 데이터 추상화 : 세부 속성, 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
    3. 제어 추상화 : 이벤트 발생의 정확한 절차, 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

  3. 단계적 분해(Stepwise Refinement)
    - 하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다. 
    - 추상화의 반복에 의해 세분화된다. 

  4. 정보 은닉(Information Hiding)
    - 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 모듈이 접근하거나 변경하지 못하도록 하는 기법

  5. 소프트웨어 아키텍처의 품질 속성
    - 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지를 확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍처 측면으로 구분하여 구체화시켜 놓은 것
    1. 시스템 측면
    2. 비즈니스 측면
    3. 아키텍처 측면 

  6. 소프트웨어 아키텍처의 설계 과정
    1. 설계 목표 설정 
      : 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 설계 목표를 설정
    2. 시스템 타입 결정
      : 시스템과 서브시스템의 타입을 결정, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택한다. 
    3. 아키텍처 패턴 적용
      : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계한다. 
    4. 서브시스템 구체화
      : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다.
    5. 검토 


    - 시스템 타입 / 협약에 의한 설계
    1. 시스템 타입
      1. 대화형 시스템 : 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템 예) 온라인 쇼핑몰 웹 애플리케이션
      2. 이벤트 중심 시스템 : 외부의 상태 변화에 따라 동작하는 시스템 예) 전화, 비상벨 등의 내장 소프트웨어
      3. 변환형 시스템 : 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템 예) 컴파일러, 네트워크 프로토콜
      4. 객체 영속형 시스템 : 예)서버 관리 소프트웨어

    2. 협약(Contact)에 의한 설계
      : 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것. 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. 
      1. 선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
      2. 결과 조건(Postcondition) : 오퍼레이션이 수행된 후 만족되어야 할 조건 
      3. 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

## <22> 아키텍처 패턴

1. 아키텍처 패턴
  - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.

  1. 레이어 패턴(Layers pattern)
    : 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중 하나
    - 각각의 서브시스템들이 계층 구조를 이루며, 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다. 
    - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다. 
    - 대표적으로 OSI 참조 모델이 있다. 

  2. 클라이언트-서버 패턴
    : 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴 
    - 사용자는 클라이언트와만 의사소통을 한다. 
    - 서버는 클라이언트의 요청에 대비해 항상 대기 상태
    - 클라이언트와 서버는 동기화되는 경우를 제외하고는 독립적이다. 

  3. 파이프-필터 패턴
    : 시스템이 파이프처럼 연결되어 있어 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복
    : 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송

  4. 모델-뷰-컨트롤러 패턴
    : 서브시스템을 3개의 부분으로 구조화하는 패턴 
    1. 모델 : 서브시스템의 핵심 기능과 데이터 보관
    2. 뷰 : 사용자에게 정보를 표시
    3. 컨트롤러 : 사용자로부터 받은 입력을 처리

  5. 기타 패턴 
    1. 마스터슬레이브 패턴 
    2. 브로커 패턴 
    3. 피어-투-피어 패턴
    4. 이벤트-버스 패턴 
    5. 블랙보드 패턴 
    6. 인터프리터 패턴 


## <23> 객체지향 (Object-Oriented)
: 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다. 
  - 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.
  - 소프트웨어의 재사용 및 확장이 용이, 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다. 
  - 복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원한다.
  - 현실 세계를 모형화하므로 사용자와 개발자가 쉽게 이해할 수 있다. 

  1. 객체(Object)
    : 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈이다. 
    1. 데이터 
     : 객체가 가지고 있는 정보. 속성이나 상태, 분류 등을 나타낸다.
     : 속성(Attribute), 상태, 변수, 상수, 자료 구조라고도 한다.
    2. 함수
     : 객체가 수행하는 기능. 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘이다.
     : 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 메소드(Method, 행위), 서비스(Service), 동작(Operation), 연산이라고도 한다. 
  객체의 특성
    1. 객체는 독립적으로 식별 가능한 이름을 가지고 있다.
    2. 객체가 가질 수 있는 조건을 상태(State)라고 하는데, 일반적으로 상태는 시간에 따라 변한다.
    3. 객체와 객체는 상호 연관성에 의한 관계가 형성된다. 
    4. 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타낼 수 있따.
    5. 객체는 일정한 기억장소를 가지고 있다.
    6. 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다. 

    - 구조적 기법
      : 프로그램 = 데이터 + 함수
    - 객체지향 기법
      : 객체 = 데이터 + 함수
      프로그램 = 객체 + 객체 

  2. 클래스 (Class)
    : 공통된 속성과 연산(행위)을 갖는 객체의 집합. 객체의 일반적인 타입을 의미한다.
    : 하나 이상의 유사한 객체를 묶어서 하나의 공통된 특성을 표현한 것으로 객체지향 프로그램에서 데이터를 추상화하는 단위가 된다. 
    - 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다. 
    - 클래스는 객체지향 프로그램에서 데이터를 추상화하는 단위이다. 
    - 클래스에 속한 각각의 객체를 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 한다. 
    - 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다. 
    - 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 말한다. 
    - 슈퍼 클래스는 특정 클래스의 상위(부모)클래스이고, 서브 클래스(Sub Class)는 특정 클래스의 하위(자식) 클래스

  3. 캡슐화 (Encapsulation)
    : 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미. 
    - 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다.
    - 캡슐화된 객체들은 재사용이 용이하다.
    - 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다. 
    - 캡슐화된 객체는 내부의 세부 정보가 숨겨져 외부의 변경으로 인한 파급 효과가 적다. 

  4. 상속 (Inheritance)
    : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
    - 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다. 
    - 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용(Reuse)을 높이는 중요한 개념이다. 
    - 다중 상속(Multiple inheritance) : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것이다. 

  5. 다형성 (Polymorphism)
    : 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체(클래스)가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미한다. 
    - 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다. 
    - 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것이다. 
    - 여러 가지 형태를 가지고 있다는 의미로 하나의 메시지에 대해 여러 가지 형태의 응답이 있다는 것을 의미

  6. 연관성 (Relationship)
    : 두 개 이상의 객체들이 상호 참조하는 관계를 말한다.
    - is member of 
      의미 : 연관화(Association)
      특징 : 2개 이상의 객체가 상호 관련되어 있음을 의미함
    - is instance of
      의미 : 분류화(Classtication)
      특징 : 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
    - is part of 
      의미 : 집단화(Aggregation)
      특징 : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
    - is a 
      의미 : 일반화(Generalization)
      특징 : 공통적인 성질들로 추상화한 상위 객체를 구성하는 것
      의미 : 특수화/상세화(Specialization)
      특징 : 상위 객체를 구체화하여 하위 객체를 구성하는 것

## <24> 객체지향 분석 및 설계

1. 객체지향 분석(OOA; Object Oriented Analysis)의 개념
  : 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링하는 작업
  - 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다.
  - 분석가에게 주요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해준다. 
  - 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적이다. 

2. 객체지향 분석의 방법론 
  1. 럼바우 (Rumbaugh) 방법 
    : 가장 일반적으로 사용되는 방법으로 분석 활동을 객체모델, 동적 모델, 기능 모델로 나누어 수행하는 방법이다.
    : 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법, 객체 모델링 기법(OMT, Object-Modeling Technique)이라고도 한다. 
    : 객체 모델링 -> 동적 모델링 -> 기능 모델링 
    1. 객체 모델링(Object Modeling)
      : 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내서 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
    2. 동적 모델링(Dynamic Modeling)
      : 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
    3. 기능 모델링(Functional Modeling)
      : 자료 흐름도(DFD)을 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다. 
    
  2. 부치 (Booch) 방법
    : 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 방법. 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다. 
  
  3. Jacobson 방법 
    : Use Case를 강조하여 사용하는 분석 방법
  
  4. Coad와 Yourdon 방법 
    : E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법이다. 

  5. Wirfs-Brock 방법 
    : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가허 설계 작업까지 연속적으로 수행하는 기법


3. 객체지향 설계 원칙
  : 시스템 변경이나 확장에 유연한 시스템을 설꼐하기 위해 지켜야 할 다섯 가지 원칙. SOLID 원칙이라고도 함

  1. 단일 책임 원칙(SRP, Single Responsibility Principle)
    - 객체는 단 하나의 책임
    - 응집도는 높고, 결합도는 낮에 설계하는 것

  2. 개방-폐쇄 원칙(OCP, Open-Closed Principle)
    - 기존의 코드 변경 x 기능을 추가할 수 있도록 설계해야 한다
    - 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적이다.

  3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
    - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙 
    - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 한다.

  4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
    - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 x
    - 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리원칙은 인터페이스가 갖는 하나의 책임이다. 

  5. 의존 역전 원칙(DIP, Dependency Inversion Principle)
    - 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다. 
    - 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다. 


## <25> 모듈
  : 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다. 
  - 단독으로 컴파일이 가능하며, 재사용 할 수 있다.
  - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어진다. 
  - 독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있다. 
  - 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다. 

  1. 결합도 (Coupling)
    : 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
    - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다. 
    - 결합도가 강하면 시스템 구현 및 유지보수 어렵다 
    - 자료 결합도 < 스탬프 결합도 < 제어 결합도 < 외부 결합도 < 공통 결합도 < 내용 결합도 (결합도 강한 정도)
    
    1. 자료 결합도 (Data Coupling)
      - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도 
      - 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식
      - 모듈 간의 내용을 전혀 알 필요가 없는 상태로서 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 미치지 않는 가장 바람직한 결합도이다.

    2. 스탬프(검인) 결합도 (Stamp Coupling)
      - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
      - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도이며, 자료 구조의 어떠한 변화, 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에까지도 영향을 미치게 된다. 

    3. 제어 결합도 (Control Coupling)
      - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달하는 결합도이다.
      - 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다. 
      - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상이 발생하게 된다. 

    4. 외부 결합도 (External Coupling)
      - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
      - 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다. 

    5. 공통(공유)결합도 (Common Coupling)
      - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다.
      - 공통 데이터 영역의 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 만든다. 

    6. 내용 결합도 (Content Coupling)
      - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.
      - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당된다. 


  2. 응집도 (Cohesion)
    : 정보 은닉(한 모듈 내부에 포함된 절차나 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 것) 개념을 확장한 것. 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미 
    : 기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도

    1. 기능적 응집도 (Functional Cohesion)
      - 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 

    2. 순차적 응집도 (Sequential Cohesion)
      - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 

    3. 교환(통신)적 응집도 (Communication Cohesion)
      - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도

    4. 절차적 응집도 (Procedural Cohesion)
      - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도

    5. 시간적 응집도 (Temporal Cohesion)
      - 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도 

    6. 논리적 응집도 (Logical Cohesion)
      - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도

    7. 우연적 응집도 (Coincidental Cohesion)
      - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

  
  3. 팬인 (Fan-In) / 팬아웃 (Fan-Out)
  팬인 
    : 어떤 모듈을 제어(호출)하는 모듈의 수 
  팬아웃 
    : 어떤 모듈에 의해 제어(호출)되는 모듈의 수 
  
    - 팬인, 팬아웃을 분석하여 시스템의 복잡도를 알 수 있다. 
    - 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요한다. 
    - 팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토 필요 
    - 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 한다.


  * N-S 차트 (Nassi-Schneiderman Chart)
    : 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고도 한다. 
    - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현 
    - GOTO나 화살표를 사용하지 않는다. 
    - 조건의 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합 
    - 선택과 반복 구조를 시각적으로 펴현 
    - 이해하기 쉽고, 코드 변환이 용이 
    - 읽기는 쉽지만 작성하기가 어려우며, 임의로 제어를 전이하는 것이 불가능 
    - 총체적인 구조 표현과 인터페이스를 나타내기가 어렵다
    - 단일 입구 단일 출구로 표현 
